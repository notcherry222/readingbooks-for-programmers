  

### 8.1 애그리거트와 트랜잭션  
  
![출처:도메인 주도 개발 책](image-1.png)  
  
위의 그림은 운영자와 고객이 동시에 한 주문 애그리거트를 생성하는 과정을 보여준다. 두 입장에서는 개념적으로는 동일한 애그리거트를 사용하지만, **물리적으로는 다른 애그리거트 객체를 사용**한다. 따라서 서로 영향을 주지 않는다.  
  
고객 스레드 입장에서는 주문 애그리거트 객체가 아직 배송 상태 전이라면 배송지 정보를 변경할 수 있다. 이 상황에서 두 스레드는 각각 트랜잭션을 커밋할 때, 수정한 내용을 DB에 반영한다. 이 순서가 운영자 스레드 입장에서 이미 기존 정보로 배송 상태를 변경할 때 나타난다면, **애그리거트의 일관성**이 깨지게 된다. 따라서 다음 두 가지 방법 중 하나를 택하여 문제가 발생하지 않도록 해야 한다.   
  
1. 운영자가 배송지 정보를 조회하고 상태를 변경하는 동안, 고객이 애그리거트를 수정하지 못하게 막는다.  
2. 운영자가 배송지 정보를 조회한 후에 고객에 정보를 변경한다면, 운영자가 애그리거트를 다시 조회한 후 수정하도록 한다.  
  
이 두 가지는 애그리거트 자체의 트랜잭션과 관련이 있다. DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요하다. 대표적으로 **선점잠금과 비선점 잠금**이 있다.  
  


### 8.2 선점 잠금  
  
