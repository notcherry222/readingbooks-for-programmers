  

### 9.1 도메인 모델과 경계  
  
앞서 읽었듯이, 한 도메인은 여러 하위 도메인으로 구분 되기 때문에 완벽하게 단일 모델을 만드는 것은 올바르지 않다. 논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다. 예를 들어 시스템을 사용하는 사람을 회원 도메인에서는 '회원'이라고 부르지만, 주문 도메인에서는 '주문자'라고 불린다.  
이렇게 하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하기 위해 우리는 명확한 경계를 가진 하위 도메인마다 모델을 만들어야 한다. **모델은 특정한 문맥 하에 완전한 의미를 갖기 때문에 이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 바운디드 컨텍스트**라고 부른다.  
   
   
   
### 9.2 바운디드 컨텍스트  
  
**바운디드 컨텍스트는 용어의 기준으로 모델의 경계를 결정하며 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다.**  
하지만 현실은 그렇지 않을 때가 많다. 바운디드 컨텍스는 **기업의 팀 조직 구조**에 따라 결정되기도 한다. 예를 들어, 주문 하위 도메인에 주문 바운디드 컨텍스트와 결제 금액 계산 바운디드 컨텍스트가 존재한다고 하면, 명확하게 용어를 구분하지 못해 두 하위 도메인을 하나의 바운디드 컨텍스트에서 구현할 때도 있다. 
<조직 구조에 따라 바운디드 컨텍스트가 결정되는 경우>  
![출처 도메인 주도 개발 책](image.png)  
  
위와 같은 상황에서 개발할 시에 **주의 점은 하위 도메인의 모델이 섞이지 않도록 하는 것**이다. 왜냐하면 하위 도메인 별로 기능을 확장하기 어렵고, 이는 서비스 경쟁력을 떨어뜨리는 원인이 되기 때문이다. 따라서 한 개의 바운디드 컨텍스트라고 해도 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 한다.  
  


### 9.3 바운디드 컨텍스트 구현  
  
바운디드 컨텍스트는 도메인 모델 뿐만 아니라 사용자에게 필요한 표현 영역, 응용 서비스, 인프라스트럭처, db와 같이 도메인 기능을 제공하는 데 필요한 영역을 모두 포함한다. 모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다.  
또한 바운디드 컨텍스트가 반드시 UI를 가지고 있어야 하는 것은 아니다. 예를 들어 상품 상세 보기 페이지를 구현할 때, 카탈로그와 리뷰 바운디드 컨텍스트에서 직접 벙보를 호출해 보여줄 수 있다. 혹은 브라우저와 바운디드 컨텍스트 사이에 UI를 처리하는 서버(프론트)를 두고 통신을 통해 사용자 요청을 처리하는 방법도 있다. 이 구조에서 UI서버는 각 바운디드 컨텍스트를 위한 파사드 역할을 수행한다.  
한 바운디드 컨텍스트에서 CRQS 패턴고 같이 여러 방식을 혼합해서 사용할 수도 있다. CQRS 패턴이란 명령 기능과 조회 기능을을 위한 모델을 구분하는 패턴이다. 이 패턴을 바운디드 컨텍스트에 적용하면, 상태 변경과 관련된 기능은 도메인 모델 기반으로 구현하고 조회 기능은 서비스-DAO를 이용해서 구현할 수 있다.  
각 바운디드 컨텍스트는 서로 다른 구현 기술을 사용할 수도 있다. 웹 MVC는 스프링 MVC를, 레포지터리 구현 기술로는 JPA를 사용할 수 있고, NETTY를 통해 REST API를 제공하고 MyBatis를 통해 리포지터리 구현 기술을 사용할 수 있다.  
