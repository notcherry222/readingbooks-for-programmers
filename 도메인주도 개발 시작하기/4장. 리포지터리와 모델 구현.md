### 4.1 JPA를 이용한 리포지터리 구현  
  
  
애그리거트를 어떤 저장소에 저장하느냐에 따라 리포지터리를 구현하는 방법은 달라진다. 대중적인 기술로는 JPA를 꼽을 수 있다.  
  
**모듈 위치**

리포지터리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처에 속한다. 리포지터리 구현 클래스를 domain.impl과 같은 패키지에 위치시키는 것은 좋은 설계 방법이 아니다. 인프라스트럭처에 대한 의존을 낮추기 위해 가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치시켜야 한다.  
  
**리포지터리 기본 기능 구현**  
리포지터리가 제공하는 기능은 ID로 애그리거트 조회하기와 애그리거트 저장하기가 있다. 애그리거트를 수정한 결과를 저장소에 반영하는 메서드를 추가할 필요는 없다. JPA를 사용하면 트랜잭션 범위에서 변경한 데이터를 자동으로 DB에 반영하기 때문이다.  
  


### 4.3 매핑 구현  

**엔티티와 밸류 기본 매핑 구현**  
애그리거트와 JPA 매핑을 위한 기본 규칙은 아래와 같다.  
1. 애그리거트 루트는 엔티티이므로 @Entity로 매핑을 설정한다.
2. 한 테이블에 엔티티와 밸류 데이터가 같이 있다면, 밸류는 @Embeddable로 매핑 설정한다.  
  


### 4.4 애그리거트 로딩 전략  
  
조회 시점에서 애그리거트를 완전한 상태가 되도록 하려면 애그리거트 루트에서 연관 매핑의 조회 방식을 즉시 로딩으로 설정하면 된다.(FetchType.EAGER) 즉시 로딩 방식으로 설정하면, 애그리거트 루트를 로딩하는 시점에 애그리거트에 속한 모든 객체를 함깨 로딩할 수 있다는 장점이 있지만, 조회 성능 문제를 항상 고려해봐야 한다.  
애그리거트는 개념적으로 하나여야 한다. 그렇다고 루트 엔티티를 토딩하는 시점에서 애그리거트에 속한 객체를 모두 로딩해야 한다는 뜻은 아니다. 애그리거트가 완전해야 하는 이유는 상태를 변경하는 기능을 실행했을 때, 애그리거트 상태가 완전해야 하기 때문인 것과 표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하기 때문이다.  
JPA는 트랜잭션 범위 내에서 지연 로딩을 허용하기 때문에 실제로 상태를 변경하는 시점에 필요한 구성 요소만 로딩해도 괜찮다.  
  


### 4.6 식별자 생성 기능  

식별자는 크게 세 가지 방식으로 생성한다.  
1. 사용자가 직접 생성 - 이메일 주소  
2. 도메인 로직으로 생성  
3. DB를 사용한 일련의 번호 사용-Generated value  
  