  
## 3.1 애그리거트 

개발을 할 때, 상위 개념을 이용해서 전체 모델을 정리하면 전체적인 관계를 이해하는 데 도움이 된다. 이와 같이 복잡한 도메인을 이해하기 용이한 단위로 만들어 도메인 요소간의 관계를 파악하기 쉽게 만든 방법이 애그리거트이다. 즉, 애그리거트란 관련된 도메인 객체를 관리하는 논리적 단위이다. 애그리거트 단위로 관리하면 일관성을 유지하기 쉬워 복잡한 도메인 구조를 단순하게 만들어 준다. 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는 데 필요한 개발 시간도 줄어든다.  
같은 애그리거트의 경계에 속한 객체는 유사한 라이프 사이클을 갖는다. 각 애그리거트는 독립된 객체 군이라 다른 애그리거트를 관리하지 않는다. 예를 들어, 주문 애그리거트에서 상품의 가격을 변경하지 않는다.  
경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다. 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다. 대부분 애그리거트가 한 개의 엔티티를 갖는다. (도메인 규칙은 객체의 일관성 유지, 유효성 검사, 비즈니스 논리 구현, 보안 및 권한 관리에 사용된다.)  
  
  
  
## 3.2 애그리거트 루트  
  
애그리거트의 일관성을 유지하기 위해 관리하는 주체가 애그러트의 루트 엔티티이다. 애그리거트 루트는 애그리거트 내부의 객체를 조합해서 완성한다. 애그리거트 루트는 단순히 애그리거트에 속한 객체를 포함하는 것 뿐만 아니라 일관성이 깨지지 않도록 하는 핵심 역할을 한다. 따라서 도메인 규칙에 따라 애그리거트 외부에서 애그리거트에 속한 객체를 직접 변경할 수 없다. 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들어야 하는데, 이때 다음 두 가지를 주의해야 한다.  
  
**1. 단순히 필드를 변경를 변경하는 set 메서드를 public 범위로 만들지 않는다.**  
**2. 밸류 타입은 불변으로 한다.**  
    
  
### 트랜잭션 범위  
  
**<권장 사항>**  
1. 트랜잭션 범위는 작을수록 좋다.  
2. 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다. 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 높기 때문이다. 또한, 애그리거트가 다른 애그리거트의 기능에 의존하게 된다면 결합도가 높아져 향후 수정 비용이 증가하므로 자기를 제외한 다른 애그리거트의 상태를 변경하지 말아야 한다. 부득이한 상황에서는 직접 수정하지 말고, 응용 서비스에서 두 애그리거트를 수정하도록 구현해야 한다.  
  
**<부득이한 경우>**  
1. 팀 표준 : 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우  
2. 기술 제약 : 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리  
3. UI 구현의 편리 : 운영자의 편리함을 위해 트랜잭션에서 여러 애그리거트의 상태를 변경.  
  


## 3.3 리포지터리와 애그리거트  
  
애그리거트는 한 개의 도메인 모델을 표현하는 개념이므로 객체의 영속성을 처리하는 리포지터리는 애그리거트 단위로 존재한다. 즉 한 개의 애그리거트는 한 개의 레포지터리를 만든다. 예를 들어, order와 orderLine이 물리적으로 각각 다른 DB 테이블에 저장된다고 해서 2개의 리포지터리를 만드는 것이 아니다. 애그리거트 루트인 order를 위한 레포지터리만 존재한다.  
리포지터리에서 save와 findById 메소드를 기본적으로 제공하는 이유도 애그리거트를 사용하려면 저장소에서 필요한 데이터를 얻어야 함에 있다. save는 애그리거트를 저장하고 findById는 id로 애그리거트를 구하는 것이다.  
  
  

## 3.4 ID를 이용한 애그리거트 참조  
  
애그리거트가 다른 애그리거트를 수정할 수는 없어도 참조는할 수는 있다. 이것은 애그리거트의 루트를 참조한다는 것과 동일한 의미이다.  
애그리거트의 참조는 필드를 통해 편리하게 구현할 수 있다. 이때는 @ManyToOne, @OneToOne 과 같은 애너테이션을 이용하여 연관된 객체를 직접 로딩한다. 이것은 개발자에게 구현의 편리함을 제공한다.  
  
하지만 이런 편리함 속에서 우리는 오용을 할 수 있다는 큰 단점이 있다. 참조를 통해 생긴 애그리거트 간의 접촉은 애그리거트의 상태를 변경할 수 있는 시발점이 될 수 있다. 또한 트래픽이 증가했을 때, 무분별하게 도메인을 나누다 도메마다 서로 다른 DBMS를 사용할 수도 있다. 성능과 관련된 여러가지 고민을 하지 않는다면, 참조한 객체를 로딩할 때 불필요한 객체도 함께 로딩될 수 있다.  
  
이런 문제점을 완화하는 것이 id를 이용해 참조하는 것이다. id 참조를 사용하면 모든 객체가 직접 연결되지 않고, 해당 객체들만 참조할 수 있다. 이것은 애그리거트의 경계를 명확하게 하기 때문에 모델의 복잡도를 낮추고 응집도는 높여준다. 그리고 리포지터리마다 다른 저장소를 사용하도록 구현할 때 확장이 용이하다. 예를 들어, 중요한 데이터인 주문 애그리거트는 RDBMS에 저장하고 조회 성능이 중요한 상품 애그리거트는 NoSQL에 저장할 수 있다.   
  

### ID를 이용한 참조와 조회 성능  
  
id로 다른 애그리거트를 참조하면 애그리거트 수가 많아졌을 때 조회 속도에서 'N+1'문제가 발생할 수 있다. 'N+1'문제란 조회 대상이 N개일 때 한 번의 쿼리와 데이터를 읽어오는 쿼리를 N번 실행한다는 뜻으로 지연 로딩과 관련된 문제이다. 이 문제는 많은 쿼리를 실행하기 때문에 전체 조회 속도가 느려지는 원인이 된다. id를 참조하면서 이런 문제를 해결하기 위해 우리는 조회 전용 쿼리를 사용할 수 있다. 예를 들어, 조회를 위한 별도의 DAO를 만들고, DAO 조회 메서드에서 조인을 이용하여 한 번의 쿼리를 호출하면 된다. JPA를 이용한다면 JPQL을 사용하면 된다.  
하지만 애그리거트가 서로 다른 저장소를 사용하면 조회 전용 쿼리를 사용할 수 없다. 이때는 성능을 높이기 위해 캐시를 적용하거나 조회 전용 저장소를 따로 구성해야 한다.  
  


## 3.5 애그리거트 간 집합 연관  
