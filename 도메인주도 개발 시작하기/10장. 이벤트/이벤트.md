  

### 10.1 시스템 간 강결합 문제  
  
환불 처리를 진행하고자 할때 발생할 수 있는 시스템적 오류를 생각해보자.  
첫 번째로, **외부 서비스가 정상이 아닐 경우 트랜잭션 처리**를 어떻게 해야 할까? 환불 기능을 실행하는 과정에서 예외가 발생하면 트랜잭션을 롤백해야 할까? 커밋해야 할까?  
이 상황에서는 환불에 실패했으므로 주문 취소 트랜잭션을 롤백하는 것이 맞아 보인다. 하지만 반드시 이 방향이 맞는 것은 아니다. 주문은 취소 상태로 변경하고 환불만 나중에 다시 시도하는 방식으로 처리할 수 있다.  
두 번째 문제는 **성능**에 대한 것이다. 환불을 처리하는 외부 시스템의 응답 시간이 길어지면 그만큼 대기 시간도 길어진다. 환불 처리 기능이 30초가 걸리면 주문 취소는 그만큼 대기 시간이 증가하는 것이다.  
세 번째로 **도메인 객체에 서비스를 전달하면 추가로 설계상 문제**가 나타날 수 있다. 주문로직과 결제로직이 섞이는 문제이다.  
이 문제들이 발생하는 공통적인 이유는 주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트 간의 강결합때문이다. 주문이 결제와 강하게 연결되어 있어 주문 바운디드 컨텍스트가 결제 바운디드 컨텍스트에 영향을 받게 되는 것이다.  
이런 경합을 없애기 위해 우리는 이벤트를 사용할 수 있다. 특히 비동기 이벤트를 사용하면 두 시스템 간의 결합을 크게 낮출 수 있다.  
  


### 10.2 이벤트 개요  
  
이 절에서 사용하는 **이벤트라는 용어는 '과거에 벌어진 어떤 것'을 의미**한다. 개발에서는 이벤트는 발생하는 것에서 끝나는 게 아니라 그 이벤트에 반응해서 원하는 동작을 수행하는 기능까지 이어져야 한다.  
  
**<이벤트 관련 구성 요소>**  
도메인 모델에 이벤트를 도입하려면 이벤트, 이벤트 생성 주체, 이벤트 디스패처(퍼블리셔), 이벤트 핸들러(구독자)가 필요하다.  
도메인 모델에서 **이벤트 생성 주체**는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체다. 이 도메인 객체는 도메인 로직을 실행해서 상태과 바뀌면 관련 이벤트를 발생시킨다.  
**이벤트 핸들러**는 이벤트 생성 주체가 발생한 이벤트에 반응한다. 이때 이벤트 생성 주체와 이벤트 핸들러를 연결해주는 것이 **이벤트 디스패처**다. 이벤트 디스패처는 이벤트 생성과 처리를 동기나 비동기로 구현할 수 있다.  
  
**<이벤트 구성>**  
이벤트는 발생한 이벤트에 대한 정보를 담는다.  
1. 이벤트 종류 : 클래스 이름으로 이벤트 종류를 표현  
2. 이벤트 발생 시간  
3. 추가 데이터 : 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보  
  
**<이벤트 용도>**  
이벤트는 크게 두 가지 용도로 쓰이는데 첫 번째는 **트리거**이다. 그리고 두 번째 용도는 서로 다른 시스템 간의 **데이터 동기화**이다. 예를들어 배송지를 변경하면 외부 배송 서비스에 바뀐 배송 정보를 전송해야 한다. 이대 주문 도메인은 배송지 변경 이벤트를 발생시키고 이벤트 핸들러는 외부 배송지 정보를 동기화할 수 있다.  
  
**<이벤트 장점>**  
1. 이벤트를 사용하면 서로 다른 도메인 로직이 섞이는 것을 방지할 수 있다.  
2. 이벤트 핸들러를 사용하면 기능 확장도 용이하다. 구매 취소 시 환불과 함께 이메일로 취소 내용을 보내고 싶다면 이메일을 발송하는 핸들러를 구현하면 된다!  
  
  
  
### 10.3 이벤트, 핸들러, 디스패처 구현 (스프링 사용)  
  
- 이벤트 클래스 : 이벤트를 표현  
- 디스패처 : 스프링이 제공하는 ApplicationEventPublisher 이용  
- Events : 이벤트 발행을 위해 디스패처 사용  
- 이벤트 핸들러 : 이벤트를 수신해서 처리  
  
이벤트 자체를 위한 상위 타입은 존재하지 않으므로 원하는 클래스를 이벤트로 사용하면 된다. 단, 이벤트는 과거에 벌어진 사건을 의미하므로 이벤트 클래스의 이름을 결정할 때는 과거 시제를 사용해야 한다. 
이벤트 클래스에는 이벤트를 처리하는 데 필요한 최소한의 데이터만 포함해야 한다. 모든 클래스가 공통으로 갖는 프로퍼티가 존재한다면 관련 상위 클래스를 만들어도 된다.  
```java
// 공통 처리를 위한 상위 클래스  
public abstract class Event {
    private long timestamp;
    
    public Event() {
        this.timestampe = System.currentTimeMillis();
    }

    public long getTimestamp() {
        return timestamp;
    }
}

// 상위 클래스를 상속받은 이벤트 클래스
public class OrderCancleedEvent extends Event {
    private String orderNumber;
    
    public OrderCanceledEvent(String number) {
        super();
        this.orderNumber = number;
    }
    ...
}
```  
  
이벤트 발생을 위해 스프링이 제공하는 ApplicationEventPublisher를 사용하여 이벤트를 발생시키도록 구현해보겠다.
```java
public class Events {
    private static ApplicationEventPublisher publisher;

    static void setPublisher(ApplicationEventPublisher publisher) {
        Events.publisher = publisher;
    }

    //이벤트 발생
    public static void raise (Object event) {
        if(publisher != null) {
            publisher.publishEvent(event);
        }
    }
}
```  
  
이벤트 퍼블리셔를 전달하기 위해 스프링 설정이 필요하다.  
```java
@Configuration
public class EventsConfiguration {
    @Autowired
    private ApplicationContext context;

    // Events 클래스를 초기화
    @Bean
    public InitializingBean eventInitializer() {
        return () -> Events.setPublisher(context); //발생 시킨 이벤트를 전달 받음
    }
}
```  
  
이벤트를 발생시킬 코드는 Events.raise() 메서드를 사용한다.  
```java
public class Order {
    public void cancel() {
        this.state = OrderState.CANCELED;
        Events.raise(new OrderCancelEvent(number.getNumber()));
    }
}
```  
  
이벤트를 처리할 핸들러는 스프링이 제공하는 @EventListener를 사용해서 구현한다.  
```java
@Service
public class OrderCanceledEventHander {
    private RefundService service;

    public OrderCanceledEventHander(RefundService service) {
        this.service = service;
    }
    
    @EventListener(OrderCanceledEvent.class) 
    public void handle(OrderCanceledEvent event) {
        service.refund(event.getOrderNumber());
    }
}
```  
ApplicationEventpublisher#publishEvent() 메서드를 실행할 때, OrderCanceledEvent 탕비 객체를 전달하면, OrderCacanceledEvent.class 값을 갖는 @EventListener가 붙은 메서드를 찾아 실행한다.  
![이벤트 처리 흐름 정리](image.png)  
**응용 서비스와 동일한 트랜잭션 범위에서 이벤트 핸들러 실행**  
